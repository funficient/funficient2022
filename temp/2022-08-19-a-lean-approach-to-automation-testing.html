<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8">
  <title>How to get started with mobbing or ensemble programming | Future of Work</title>
  <meta name="description" content="A practical, experience-based guide to ensemble programming (mob programming): why it works, how to get started, and how it improves quality, learning, and team relationships.">
  <meta name="author" content="Kate Dames">
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">  
  <link rel="preconnect" href="https://use.fontawesome.com" crossorigin>
  <link rel="stylesheet" href="/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 

  <link rel="canonical" href="https://www.funficient.com/future-of-work-resources/how-to-get-started-with-mobbing-or-ensemble-programming.html">
  <meta name="keywords" content="ensemble programming, future of work, teal organizations, self-management, mob programming, mobbing, agile teams, software collaboration, knowledge sharing">

  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="How to get started with mobbing (or ensemble programming)">
  <meta property="og:description" content="Why ensemble programming works, how to get started, and how it improves quality, learning, and collaboration.">
  <meta property="og:url" content="https://www.funficient.com/future-of-work-resources/how-to-get-started-with-mobbing-or-ensemble-programming.html">
  <meta property="og:image" content="https://www.funficient.com/assets/funficient-4d-way.png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="How to get started with mobbing (or ensemble programming)">
  <meta name="twitter:description" content="A beginner-friendly, experience-based guide to ensemble programming and mob programming.">
  <meta name="twitter:image" content="https://www.funficient.com/assets/funficient-4d-way.png">

  <script src="/scripts/navigation.js" defer></script>

  <!-- Article Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "@id": "https://www.funficient.com/future-of-work-resources/how-to-get-started-with-mobbing-or-ensemble-programming.html",
    "headline": "How to get started with mobbing (or ensemble programming)",
    "description": "A practical guide to ensemble programming (mob programming), explaining why it works, how to get started, and how it improves quality, learning, and team relationships.",
    "articleBody": "This article introduces ensemble programming (also known as mob programming or mobbing), a collaborative practice where three or more people work together on the same problem, at the same time, on the same codebase. Drawing on principles from Extreme Programming (XP), lean thinking, and real-world team experience, it explains why ensemble programming improves software quality, learning, focus, and team relationships.\n\nUsing the metaphor of a jazz band, the article explores how shared flow, real-time feedback, and multiple perspectives turn individual skill into collective outcomes that no one could create alone. It outlines the key benefits of ensemble programming, including reduced waiting time, fewer defects, improved onboarding, better communication, and increased resilience by avoiding knowledge silos.\n\nThe article then provides a practical, beginner-friendly guide to getting started with ensemble programming. It covers essential roles such as driver and navigator, the importance of regular rotation, ideal group size, task selection, supporting tools, voluntary participation, and the role of reflection through retrospectives. The focus is on creating sustainable, human-centered collaboration rather than maximizing individual output.\n\nOverall, the article positions ensemble programming as a powerful practice for modern, remote, and knowledge-based teams that want to improve quality, learning, and trust while building stronger relationships and shared ownership.",
    "author": {
      "@type": "Person",
      "@id": "https://www.funficient.com/#kate-dames",
      "url": "https://www.funficient.com/about.html"
    },
    "publisher": {
      "@type": "Organization",
      "@id": "https://www.funficient.com/#organization",
      "url": "https://www.funficient.com"
    },
    "datePublished": "2022-05-10",
    "dateModified": "2026-01-15",
    "about": {
      "@type": "Thing",
      "name": "Teal organizations",
      "description": "A self-managed organizational model focused on wholeness, purpose, and evolutionary development."
    },
    "isPartOf": {
      "@type": "WebPage",
      "@id": "https://www.funficient.com/future-of-work-resources.html"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://www.funficient.com/future-of-work-resources/how-to-get-started-with-mobbing-or-ensemble-programming.html"
    },
  "mentions": [
    {
      "@type": "DefinedTerm",
      "@id": "https://www.funficient.com/#teal-transformation"
    },
    {
      "@type": "Service",
      "@id": "https://www.funficient.com/#coaching-service"
    },
    {
      "@type": "Course",
      "@id": "https://www.funficient.com/#teal-course"
    }
  ],
  "hasPart": [
    { "@type": "WebPageElement", "name": "Benefits of ensemble programming" },
    { "@type": "WebPageElement", "name": "How to get started with ensemble programming" }
  ],
  "inLanguage": "en",
  "keywords": [
      "ensemble programming",
      "mob programming",
      "mobbing",
      "extreme programming",
      "agile teams",
      "software collaboration",
      "knowledge sharing"
    ],
  "citation": [
    "https://lean.org/lexicon/one-piece-flow",
    "https://www.youtube.com/watch?v=Yqi9Gwt-OEA",
    "https://www.agilealliance.org/glossary/xp/",
    "https://www.researchgate.net/publication/328150167_Mob_Programming_A_Qualitative_Study_from_the_Perspective_of_a_Development_Team",
    "https://www.youtube.com/channel/UCgt1lVMrdwlZKBaerxxp2iQ"
  ],
  "speakable": {
  "@type": "SpeakableSpecification",
  "xpath": [
    "/html/body//h1",
    "/html/body//article//p[1]"
  ]
}
}
</script>

  <!-- FAQ Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is ensemble programming?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Ensemble programming, also known as mob programming or mobbing, is a collaborative practice where three or more people work together on the same problem, at the same time, on the same codebase."
        }
      },
      {
        "@type": "Question",
        "name": "Is ensemble programming the same as pair programming?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "No. Pair programming involves two people, while ensemble programming involves three or more participants collaborating simultaneously."
        }
      },
      {
        "@type": "Question",
        "name": "Does ensemble programming reduce productivity?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "While it may appear slower initially, ensemble programming often increases overall throughput by reducing rework, defects, and knowledge silos."
        }
      }
    ]
  }
  </script>

</head>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Kate Dames" />
  <meta name="description" content="Automation is an insurance policy. First, you have to make sure that you have a product worth insuring before you start investing in the premiums. Here’s a leanapproach to automation testing." />
  <title>A Lean Approach to Automation Testing</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">A Lean Approach to Automation Testing</h1>
<p class="author">Kate Dames</p>
<p class="date">2017-07-20T10:16:35.733Z</p>
</header>
<h2 id="a-test-strategy-process-defined">A test strategy process
defined</h2>
<p>In a previous post I looked at <a
href="https://medium.com/@funficient/what-is-agile-testing-exactly-1dabb7f09e8"><strong>what</strong>
agile testing is</a> after commenting on a discussion by <a
href="https://medium.com/u/a59f796c6fc6?source=post_page-----ad6fcdcf41e3--------------------------------">Lisa
Crispin</a> and <a
href="https://medium.com/u/e4cbf86c42e8?source=post_page-----ad6fcdcf41e3--------------------------------">Janet
Gregory</a> on <a
href="http://agiletester.ca/definition-agile-testing/">defining a
definition for agile testing</a>. My view is that (functional
end-to-end) automating too soon is not agile. To be really agile, manual
testing is by far the fastest and most flexible in most cases. This post
aims to drill into <strong>how</strong> I automate and what to include
and exclude. It focuses on validation testing from an end-user
perspective.</p>
<p>In essence, I view automation as an insurance policy. It makes sure
that the software still works the way it was intended to work when other
parts of the system has changed. Once I’ve automated a part of the
system, I trust that it does the testing and I don’t have to look at it
anymore, allowing me to focus my full attention on the new bits and
pieces that were added.</p>
<h2 id="the-strengths-and-constraints-of-automation">The strengths and
constraints of automation</h2>
<p><em>As with all things in life, nothing is perfect. Just like you
wouldn’t use a pasta machine to make cookies, so too you pick the right
tool or technique to get the most out of the testing experience. That
means knowing what humans are good at and their constraints, and what
automation is good at and its constraints.</em></p>
<p>Humans are good at spotting discrepancies. They are also good at
figuring out <em>why</em> something isn’t working or <em>where</em> the
error lies. Technology, however, is much better at repeating the same
work over and over and over and over again. Where humans get bored and
distracted and accustomed to what is in front of them, technology
thrives when able to repeat the same thing over and over again. When a
human is asked to do the same task over and over again though, chances
are high that they will miss errors.</p>
<p>Technology is thus an excellent partner to take over everything that
becomes boring to a human being after it’s been proven to be stable. It
is however expensive and inflexible. In order to change a test, you need
to change the tool, which is inherently much slower than a human being
simply checking something manually. The more tests you add, the more
resources you need, but everything is double the cost as you have to pay
for the hardware and possible software licenses as well as the human
being managing it.</p>
<p>Technology also becomes unmanageable very soon when
<em>everything</em> is being automated, which often tends to be the
case. Soon it takes longer to run the automated tests and get the
results than simply doing it manually. In my opinion, it’s of little
value having an automation test but not being able to get results on
demand. It’s like having a health insurance policy but when you have to
go to hospital for an emergency treatment, they tell you that they can
only help you in a few weeks’ time. You need the treatment now in order
to stay alive and the insurance policy means nothing if it doesn’t give
you the re-assurance that it is intended to give and what you signed up
for.</p>
<p>Trying to make sense of the automated tests becomes increasingly
harder the more tests are added, meaning it takes more and more time for
the engineer to find the right tests and update all the relevant tests
with each change to the system.</p>
<p>Technology also only does what it’s told. It doesn’t find an error
when it hasn’t been automated whereas a human being would more easily be
able to spot a new bug that was introduced.</p>
<p>Finally, users do things differently. Everyone has slightly different
preferences, settings and work flows and not all transactions require
the same workflow. It’s impossible (or at least impractical) to test all
the different combinations, and thus impractical to automate it all.
Technology looks at exactly the same work flows and data every time, so
any work flow or accidental click that happens in real life, is omitted
when only automating.</p>
<p>Automation is thus really good for stable parts of the system which
is used often and in a repeatable way.</p>
<h1 id="an-automation-test-strategy">An automation test strategy</h1>
<p>Taking these strengths and constraints of automation in place, here
is how I decide what to automate.</p>
<p>As a rule of thumb, I automate 20% of the tested function(s),
according to the 80/20 Pareto rule that states that roughly 80% of
effects come from 20% of the causes.</p>
<blockquote>
<p><em>The art of testing is knowing which 20% to automate.</em></p>
</blockquote>
<h2 id="deciding-what-to-exclude">Deciding what to exclude</h2>
<p>First, I look at what can be excluded by spending time with the
developers to find out what is already covered in unit tests and how the
architecture is designed. Often, the same code is used in different
places but from a front-end point of view it’s impossible to tell, and
often times, when I do guess that it’s the same code being re-used, I’m
wrong.</p>
<p>So my step number one is to really understand what makes sense to
automate and what can safely be excluded.</p>
<p>Secondly, I exclude unnecessary details. These vary greatly from one
system and work flow to the next. It might be considered unnecessary in
one case to test all the different inputs into a new data field to
ensure that the field validations and error messages works, whereas in a
different case, this might be the most important tests to automate.</p>
<blockquote>
<p>Context is everything.</p>
</blockquote>
<p>It’s all about evaluating risk within context. Is it risky for the
business? Is it risky for the technology? Is it risky for the users? For
example in health care there are patient safety requirements which might
look as unnecessary details when viewed in relation to the system
functions, but these might cause some form of harm to the patient and is
absolutely crucial to include in the automated tests.</p>
<p>However, when there are 10 different work flows of which only 2 are
commonly used, I would only automate the 2 most-used ones and exclude
the rest, based on a risk assessment. Or, I would add variations of
these 8 less used work flows into other tests.</p>
<blockquote>
<p><em>Knowing what is important and what is not requires
conversations.</em></p>
</blockquote>
<p>Speak to the Product Owner, speak to user support, speak to the
customers, and speak to the developers. They all provide valuable
insights that will help you decide what, from an operational
perspective, is important and what not.</p>
<p>Regression and automation testing, from my perspective, becomes
needed and important when you move into the Ops part of DevOps. It is no
longer good enough to only speak to the technical team and the focus
must shift to how it’s being used in the field.</p>
<h2 id="deciding-what-to-include">Deciding what to include</h2>
<p>The first place to look for inclusions is to go through the errors
identified during the sprint and see where the weak spots in the system
lie. In plumbing, when a pipe has a weak spot, it tends to start leaking
in the same spot rather than a random new spot. The same principle
applies to software, thus it’s crucial to include high risk errors or
areas where there were a lot of errors in the automation.</p>
<p>Second, I evaluate the risk areas from a business perspective. Some
things might seem trivial to a developer but is super important to the
business function and reputation of the company. These items you want to
at least cover somewhere.</p>
<p>Third, I look at the users and which areas of the system they use
most. Where does most of the work get done and what kind of data is
used? If possible, I speak to real users and get samples of real data to
include. Analysing real data is a super helpful tool to understand how
users really use the system as opposed to how they ‘should’ be using the
system.</p>
<p>I once met a guy who built hiking trails for a living and I asked him
how he knows his trails are successful. He told me that he uses it
himself, and he looks for evidence of how users are using it. It’s quite
easy to spot where users get off the trail and can then add a clear
marker. He doesn’t try to force the users to use the trail as he
intended it to be built, he takes feedback from the real users and
adapts the trail accordingly. The same should be true for software. The
real users should be telling us how the system is being used and what
the needs are. Where do users get confused? Where does users input wrong
data in the fields?</p>
<p>Finally, I look at what has already been automated and how this can
be re-used, or possibly made redundant. When automated tests keep
passing consistently, it might be safe to modify them or even remove
them. When automated tests keeps failing, it might be necessary to add
more tests to make trouble shooting easier.</p>
<p>I then build a test suite trying to cover most of these inputs into
the least amount of test scenarios as possible, by including for example
different combinations of data in different work flows to get as much
coverage as possible with the least amount of effort.</p>
<p>The key differentiator between unit tests and regression tests in my
opinion is that unit tests cover the small, standalone functions.
Regression tests should always aim to include an entire work flow from
logging in to logging out after completing a specific objective or task.
The log in function might work and the next function might also work
separately, but logging in and then immediately trying to do something
in a sequence are where the value of regression comes in.</p>
<h1 id="conclusion">Conclusion</h1>
<p>It’s easy to add just one more test and just one more function. The
art of testing is trying to remove just one more test and still cover
all the functions.</p>
<p>Automating tests should be kept lean in order to consistently add
value.</p>
<p><em>Originally published on Medium:
https://medium.com/teal-times/a-lean-approach-to-automation-testing-ad6fcdcf41e3</em></p>
</body>
</html>
