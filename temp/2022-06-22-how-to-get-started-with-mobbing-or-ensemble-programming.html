<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Kate Dames" />
  <meta name="description" content="Some of my best memories involves live music. When a group of talented musicians get together magic happens. But I’m not a musician. My art is the art of software development, which is strikingly similar to the art of making music. But it takes more than talent to create a great team." />
  <title>How to get started with mobbing (or ensemble programming)</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">How to get started with mobbing (or ensemble
programming)</h1>
<p class="author">Kate Dames</p>
<p class="date">2022-05-10T17:52:12.711Z</p>
</header>
<p><em>Music has been an important part of my life from my early
childhood.</em> Some of my best memories involves live music. When a
group of talented musicians get together magic happens. Time stands
still as I observe the play between different instruments to create
art.</p>
<p>But I’m not a musician. My art is the art of software development,
which is strikingly similar to the art of making music. It takes more
than talent to create a great team.</p>
<h2 id="extreme-relationships">Extreme relationships</h2>
<p>XP has been a big part of my journey and is what I look at for the
day-to-day <strong><em>how to</em></strong>. What I love about XP is
that it is rather like the pot of gold at the end of the rainbow. It
suggests a few ingredients that will create autonomous, productive teams
that are able to deliver high-quality software, without prescribing an
exact recipe. It focuses on practices that create high performing teams
much like a chef will look at different ingredients and create various
dishes from the same ingredients.</p>
<p>XP originated by answering a simple question — <em>what works, and
how can we take that to the extreme?</em></p>
<blockquote>
<p>XP aims to amplify the good in teams that help them deliver
high-quality software.</p>
</blockquote>
<p>Naturally, mobbing, or ensemble programming, is an essential method
to look at as it amplifies not only the real-time skills when working on
a specific problem, but also the relationships. And let’s face it. It’s
the relationships that keep you in your day job even when you dislike
your boss or the structure or even the product you are working on.</p>
<p>When you have strong relationships in a team, no problem is too big
or too difficult to resolve. When, however, you have weak relationships,
the smallest problem can cause the entire product to fall apart.</p>
<blockquote>
<p>Like a good jazz band, ensemble programming is when a bunch of
artists come together to build stuff. Good stuff.</p>
</blockquote>
<p>Each artist brings a unique skill to the table and adds it to amplify
the experience of building software. Of course, you can use the same
technique in any industry, not only software development.</p>
<h2 id="benefits-of-ensemble-work">Benefits of ensemble work</h2>
<p>At first glance it might seem very unproductive to have 3 or 5 people
working on the same piece of software when each could work on a separate
piece. Although it sounds counter-intuitive there are, however, more
benefits than disadvantages of having a group of people work on the same
problem at the same time.</p>
<p>There has been some research on the relative productivity that
supports this, but as it is still a very new practice, it has not been
studied extensively. Watch the <a
href="https://www.youtube.com/channel/UCgt1lVMrdwlZKBaerxxp2iQ">Mob
Mentality podcast</a> for interviews with some of the pioneers in the
field.</p>
<p>But it doesn’t take any scientific research to grasp some of the
benefits of working together as listed below:</p>
<h3 id="real-time-feedback">1. Real-time feedback</h3>
<p>Probably the biggest benefit from ensemble programming is that you
get real-time feedback on your work, thus drastically reducing and even
eliminating the biggest waste in most teams, namely <em>waiting
time</em>.</p>
<p>One of the practices that have proven beneficial to increasing the
quality of the software is code reviews. The problem with code reviews,
however, is that often you spend a lot of time waiting for the reviewer
to give feedback and both waste time in context switching which reduces
productivity.</p>
<p>So how do you take the benefit of a peer looking at your code to the
extreme? You have an ensemble session. Of course.</p>
<p>With ensemble programming, waiting time is eliminated, unless you
uncover a problem that requires someone that is not in the session.
Usually, however, all the people are there and you get real-time
feedback from multiple perspectives on your code as you write it.</p>
<h3 id="multiple-perspectives">2. Multiple perspectives</h3>
<p>This leads me to the next big benefit, namely adding multiple
perspectives to any given problem.</p>
<p>I strongly believe that each person has a unique skill and that no
two people have the same superpower. There is no one programmer better
than another. They merely have a different skill set, or pattern
recognition ability, than the next. While one might be good at one
aspect of coding, like security, another might be good at algorithms,
while another might be good at testing and thinking about edge cases.
Putting these perspectives together greatly increases the overall
quality of the product early on.</p>
<p>Adding perspectives reduces errors and requirements identified after
the code has been released, which exponentially reduces the cost of
correcting the error or addressing the requirement.</p>
<p><img
src="https://miro.medium.com/max/1400/1*PwCkRPJRsZ8vNlEcFNxD6A.png" /></p>
<p>You can’t test quality into a product. You have to build it in from
the start. When you include multiple perspectives early on, it increases
the completeness of your design.</p>
<h3 id="increased-focus">3. Increased focus</h3>
<p>In lean manufacturing there’s a principle called <strong>one-piece
flow</strong>, which Henrik Kniberg translated nicely to be understood
for all industries <a
href="https://www.youtube.com/watch?v=Yqi9Gwt-OEA">here</a> using the
analogy of drawing smiley’s:</p>
<p><a
href="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FYqi9Gwt-OEA%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DYqi9Gwt-OEA&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FYqi9Gwt-OEA%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube">Henrik
Kniberg : Multiple WIP vs One Piece Flow Example</a></p>
<p>The principle essentially means that if you focus on completing one
thing at a time (also called the Definition of Done in Scrum), you
increase flow, or your ability to produce more items in less time. Again
counter-intuitive as most people believe that it is more productive to
start multiple projects and show progress on each. Scientifically
tested, however, this is merely an incorrect perception and it is never
faster to run concurrent projects than focus on one piece at a time.</p>
<p>When you are part of an ensemble you are naturally more focused and
motivated. The rotating of roles ensures that you always keep your
attention on what’s going on without burning out as there are rest times
between rounds.</p>
<p>A side benefit is that it will decrease the work-in-progress, which
is usually an indication of busywork rather than productive work. It
will also naturally force you to prioritize work better.</p>
<h3 id="level-out-skills">4. Level out skills</h3>
<p>Ensemble programming is also a useful tool to use during onboarding,
as it levels out skills, similar to the lean principle of leveling out
the workload.</p>
<p>In an increasingly remote first work environment, onboarding becomes
even more important than it was with a co-located team. Suddenly the new
person has no one to ask unless explicitly introduced to someone as they
don’t overhear water-cooler conversations that might prompt someone to
realize who is good at what.</p>
<p>An ensemble session at least once a week is a great tool to distill
culture and best practices in a friendly, yet productive, environment.
It also allows different skill levels in different areas to
cross-pollinate. A junior developer can grow their confidence in the
codebase much faster without needing to interrupt another team member,
while a senior developer can instill the practices they’ve learned over
the years without needing to write extensive documentation.</p>
<p>Leveling out skills also means that you are no longer reliant on one
single key developer to work on a piece of software. There is thus no
bottleneck and there’s a higher contingency when one of the ensemble is
not available for some or other reason. The work can go on without
requiring one specific person to be present, which in my opinion is a
huge benefit.</p>
<h3 id="improved-communication">5. Improved communication</h3>
<p>By far the biggest benefit in my view, however, is the improved
communication that an ensemble session requires. Because the driver has
to take instructions from the navigator they have to practice their
active listening skills, while the navigator has to learn to become a
better teacher and putting words to often abstract ideas in their
minds.</p>
<p>Although it might be faster and easier to just do it yourself in the
short term, it is always faster and easier to upskill the person for
long-term gains.</p>
<p>By far one of the biggest obstacles in leveling up skills from a
junior developer to become more senior is having someone explain how to
do things within context. I have seen so many times how really clever
developers work become obsolete simply because they are unable to
explain it to another and it is easier to redo it than to figure it
out.</p>
<h2 id="how-to-get-started-with-ensemble-programming">How to get started
with ensemble programming</h2>
<p>While there are many more benefits to having an ensemble session,
let’s move on to how to get started.</p>
<h3 id="understand-the-different-roles">1. Understand the different
roles</h3>
<p>First and foremost it is essential that each participant understands
the different roles and who is responsible for what during a
session.</p>
<p>At Cucumber’s new contributor’s ensemble, we created a manifesto to
remind us why we’re there and what’s most important, together with a
summary of the different roles. We use this at the start of each session
and have it available for people to reference at any times.</p>
<p><img
src="https://miro.medium.com/max/1400/1*6zhnliNOiX7nGzIYgouJ5g.png" /></p>
<p>The top part contains our most important values, while the bottom
part summarizes the different ensemble roles, namely the driver,
navigator, and next-up.</p>
<p>Thinking of the analogy of a <a
href="https://www.subaru.co.za/tech/difference-between-off-road-driving-rally-driving/">rally</a>
race, ensemble programming has a driver who is the person behind the
keyboard (or wheel in a rally) and the only one typing, while the
navigator relays instructions on what to do and is the final
decision-maker. Any other participants are added to a pool of next-up
players who awaits their turn to take the driver or navigator role as it
rotates.</p>
<p>If you are not the active driver or navigator, you can do research to
help the driver and navigator, point out errors, or contribute in any
other way. If there is more than one person in the next-up pool of
participants, it could be useful to assign a specific perspective to
them — either what they are already very skilled at, or something they
want to get better at.</p>
<h3 id="rotate">2. Rotate</h3>
<p>One of the reasons why ensemble programming is so much more engaging
than traditional programming is that each role is time-boxed and
rotates, thus everyone gets a chance to be the driver and the
navigator.</p>
<p>We use <strong><a href="https://mobti.me/">mobti.me</a></strong> to
keep track of who is which role and ensure that we give everyone a fair
and equal chance behind the keyboard. By default the time box is set to
5 minutes, which means that even if you are brand new to coding, it is
possible to sit through 5 minutes of discomfort.</p>
<p>We recently started changing our rotation based on tasks rather than
time, thus you don’t have to use a timer. What is more important is,
like <a
href="https://funficient.medium.com/5-ways-to-play-lean-coffee-bded05853562">lean
coffee</a>, you rotate and everyone gets an equal chance to
participate.</p>
<p>Limit the session to 90–120 minutes to start with. Less than an hour
might be too short to get value out of it, while more than 2 hours
requires a break.</p>
<h3 id="limit-contributors">3. Limit contributors</h3>
<p>From my own experience and talking with other practitioners who have
used ensemble programming in different setups, like any team, the sweet
spot is 3–5 participants at a time.</p>
<p>The minimum number of participants to be considered an ensemble is
three, one person for each of the primary roles. The maximum productive
limit is five participants in my opinion, although some teams include
more than 5 people.</p>
<p>My experience has been that engagement drops when the time between
driver role become too long. Or, in other words, the ratio of time being
an active participant (driver or navigator) should be at least 3 times
as much as the passive participant role to keep engagement high.</p>
<p>I would recommend 3 or 4 people as the core team and invite add-on
roles for specific sessions based on needs as they arise. For example,
maybe you want to include a product owner, or someone strong in a
specific technical skill to help you complete a goal.</p>
<h3 id="pick-the-right-task">4. Pick the right task</h3>
<p>This is probably the hardest part to get right. Make sure the task is
not too difficult or too easy. It needs to be a task that requires
problem-solving. There needs to be a reason to have collaboration in
other words.</p>
<p>If it is something like grind work that just needs to get done, it
would most probably be more productive and engaging to just go do it.
However, it might be much more fun to take boring and repetitive grind
work and do it together in other cases. It really depends on the task at
hand and the personlities within the team.</p>
<p>It is recommended to start with easy, small tasks that can be
completed in one session just to get used to the mechanics of
ensembling. However, as you become more familiar with the mechanics,
pick more complex tasks that require problem-solving, similar to how you
would select complex pieces of code to go for a review rather than just
everything.</p>
<h3 id="get-the-right-tools">5. Get the right tools</h3>
<p>There are a growing number of tools available to enable code sharing
sessions. We mostly use <a
href="https://code.visualstudio.com/learn/collaboration/live-share?msclkid=aee46e49cfa211ec82032f13cb85231e">VS
Code Live Share</a> which is good except for a few annoying bugs, and <a
href="https://www.jetbrains.com/idea/download/#section=windows">IntelliJ</a>
is a very good alternative that we’re currently experimenting with which
is a bit better with permission management. They also have a built-in
call option which allows you to use one tool rather than having to use
another video conference tool and the code editor.</p>
<p>One of the biggest complaints from the earliest mobbers were that it
takes too much time to sync code between rotations. Using live code
share allows all the participants to contribute to the same codebase
without needing to sync code manually.</p>
<p>You will also need a <strong>timer</strong>. As mentioned earlier, we
use mobti.me and there is a range of options available so pick one you
like most. You can even use google timer or your phone if you don’t have
any other timer.</p>
<p>Things to look out for when selecting a timer are the ability to add
names, the ability to rotate, and the ability to change the time
interval.</p>
<h3 id="make-it-voluntary">6. Make it voluntary</h3>
<p>As a professional “playoneer” (someone who understands play and the
mechanics of play and uses it as a tool for creativity and innovation),
I strongly believe in voluntary contribution. If people <em>choose</em>
to show up, it works. If people only show up because they <em>have
to</em>, it doesn’t really work and you have a false sense of
confidence. It might be harder to face reality if it isn’t what you
want, but it’s always harder to face the consequences of living in a
bubble.</p>
<p>To get maximum buy-in and participation it is essential to make these
sessions voluntary. The <a
href="https://ktchange.com/openspace.html">law of two feet</a> should
always apply which gives people the freedom without any negative
consequences to leave the session if they feel they are not contributing
or getting anything out of the session.</p>
<h3 id="reflect-regularly">7. Reflect regularly</h3>
<p>Finally, the single most important rule of all continues improvement
programs is to reflect and allow a space to critically evaluate what’s
working and what not.</p>
<p>This is the one requirement that can not be omitted. Even if you
break all the other rules, having the space to reflect and learn will
probably lead you to include all the rules gradually and so much
more.</p>
<p>Agility is the ability to respond to change. The retrospective and
reflective spaces are the single most important aspect to rate a team’s
agility. End each ensemble session with a retrospective to identify
successes and actions to improve.</p>
<p>Even more important than identifying actions is to act on it. Ensure
that there’s not too many actions and that the actions get checked off
before adding new ones.</p>
<p>And that’s a beginner’s guide to getting started with ensemble
programming.</p>
<p><em>If you need help implementing ensemble sessions at your
workplace, visit <strong><a
href="https://www.funficient.com/workshops.html">www.funficient.com</a></strong>
and book an ensemble session.</em></p>
<p><em>Original article posted on
https://funficient.medium.com/where-does-design-fit-into-the-development-life-cycle-342c8dc12fbc</em></p>
</body>
</html>
